---
layout: post
title:  "[2021 KHUTHON] 좋은 말 고운 말"
summary: 
author: hipass7
date: '2021-11-13 21:00:00 +0900'
category: python
thumbnail: /assets/img/14/1.png
permalink: /blog/14/
---

# [2021 KHUTHON] 좋은 말 고운 말

- 2021 KHUTHON (경희대 해커톤)
- AI로 극복하는 재난

### 도입

2021년 11월 12일부터 13일까지 무박 2일동안 경희대학교 중앙동아리 KHLUG에서 주최하는 KHUTHON에 참가한 프로젝트 결과물입니다. 이번 글에서는 발표 형식으로 이번 결과물을 소개할 예정입니다.

**재난?**

주제가 AI로 극복하는 재난이라고 주어졌을 때, 모든 분야에서의 AI 접목은 어렵지 않을 것이라고 판단되어 재난에 대해 먼저 생각해보았습니다. 현재 코로나19 팬데믹 상황을 겪고 있는 만큼 위드코로나를 위한 프로그램에 대해 생각해보고 싶었으나, 독창성이 떨어질 것을 염려하여 산불, 교통사고 등 다른 재난을 생각하다가 아주 세부적인 재난에 대해서 다루기로 하였습니다. 그것은 바로 자살이었습니다.

**자살률 증가**

뉴스에서 우리나라 자살률이 증가했다는 멘트를 자주 볼 수 있었습니다. 이 자살률 증가 원인 중 하나로 우울증을 꼽았고, 이 우울증은 인간 관계에서 서로 간의 상처로 인해 발생한다고 생각했습니다. 따라서 서로 상처줄 수 있는 말들을 교정해줄 수 있는 AI 프로그램에 대해 생각해보기로 했습니다.

**실시간 음성 욕설 인식**

Google Cloud Speech API를 사용해서 음성 파일을 텍스트로 변환하는 작업을 하였습니다. 이후 음성 파일이 아닌 마이크로 실시간 스트리밍하는 레퍼런스도 참고하여 만들 수 있었습니다. 텍스트 파일로 욕설 단어 데이터를 불러와서 해당 되는 단어가 들어가있는 부분을 캐치하여 어떤 욕설을 몇 회 하였는지 기록하게 됩니다.

**데이터베이스 및 웹 구축**




```c++
// Header file for Unsorted List ADT.  
#include <iostream>
using namespace std;
template <class ItemType>
struct NodeType;

// Assumption:  ItemType is a type for which the operators "<" 
// and "==" are defined-either an appropriate built-in type or
// a class that overloads these operators.

template <class ItemType>
class SortedType
{
public:
  SortedType();     // Class constructor	
  ~SortedType();    // Class destructor

  bool IsFull() const;
  // Determines whether list is full.
  // Post: Function value = (list is full)

  int  LengthIs() const;
  // Determines the number of elements in list.
  // Post: Function value = number of elements in list.

  void MakeEmpty();
  // Initializes list to empty state.
  // Post:  List is empty.

  void RetrieveItem(ItemType& item, bool& found);
  // Retrieves list element whose key matches item's key 
  // (if present).
  // Pre:  Key member of item is initialized.
  // Post: If there is an element someItem whose key matches 
  //       item's key, then found = true and item is a copy 
  //       of someItem; otherwise found = false and item is 
  //       unchanged. 
  //       List is unchanged.

  void ResetList();
  // Initializes current position for an iteration through the
  // list.
  // Post: Current position is prior to list.

  void GetNextItem(ItemType&);
  // Gets the next element in list.
  // Pre:  Current position is defined.
  //       Element at current position is not last in list.
  // Post: Current position is updated to next position.
  //       item is a copy of element at current position.
  
  void InsertItem(ItemType item);
  void DeleteItem(ItemType item);
  void PrintReverse();
  void FindItem(NodeType<ItemType>* listData,
      ItemType item,
      NodeType<ItemType>*& location,
      NodeType<ItemType>*& predLoc,
      bool& found);

private:
  NodeType<ItemType>* listData;
  int length;
  NodeType<ItemType>* currentPos;
};
template<class ItemType>
struct NodeType
{
    ItemType info;
    NodeType* next;
};
template <class ItemType>
SortedType<ItemType>::SortedType()  // Class constructor
{
  length = 0;
  listData = NULL;
}
template<class ItemType>
bool SortedType<ItemType>::IsFull() const
// Returns true if there is no room for another ItemType 
//  on the free store; false otherwise.
{
  NodeType<ItemType>* location;
  try
  {
    location = new NodeType<ItemType>;
    delete location;
    return false;
  }
  catch(bad_alloc exception)
  {
    return true;
  }
}
template <class ItemType>
int SortedType<ItemType>::LengthIs() const
// Post: Number of items in the list is returned.
{
  return length;
}
template <class ItemType>
void SortedType<ItemType>::MakeEmpty()
// Post: List is empty; all items have been deallocated.
{
    NodeType<ItemType>* tempPtr;

    while (listData != NULL)
    {
        tempPtr = listData;
        listData = listData->next;
        delete tempPtr;
    }
    length = 0;
}
template <class ItemType>
void SortedType<ItemType>::RetrieveItem(ItemType& item, 
     bool& found)
{
  bool moreToSearch;
  NodeType<ItemType>* location;

  location = listData;
  found = false;
  moreToSearch = (location != NULL);

  while (moreToSearch && !found)
  {
    if (location->info < item)
    {
      location = location->next;
      moreToSearch = (location != NULL);
    }
    else if (item == location->info)
    {
      found = true;
      item = location->info;
    }
    else
      moreToSearch = false;
  }
}

template <class ItemType>
void SortedType<ItemType>::ResetList()
// Post: Current position has been initialized.
{
  currentPos = NULL;
}
 
template <class ItemType>
void SortedType<ItemType>::GetNextItem(ItemType& item)
// Post:  Current position has been updated; item is 
//        current item.
{
  if (currentPos == NULL)
    currentPos = listData;
  item = currentPos->info; 
  currentPos = currentPos->next;

} 

template <class ItemType>
SortedType<ItemType>::~SortedType()
// Post: List is empty; all items have been deallocated.
{
    NodeType<ItemType>* tempPtr;
    int length = LengthIs();
    for (int i = 0; i < length; i++)
    {
        tempPtr = listData;
        listData = listData->next;
        delete tempPtr;
    }
  }

template<class ItemType>
void SortedType<ItemType>::FindItem(NodeType<ItemType>* listData,
    ItemType item,
    NodeType<ItemType>*& location,
    NodeType<ItemType>*& predLoc,
    bool& found)
    // Assumption: ItemType is a type for which the operators ''<'' and
    //      "==" are defined as either an appropriate built-in type or a
    //      class that overloads these operations.
    // Pre: List is not empty.
    // Post:If there is an element someItem whose key matches item's
    //      key, then found = true; otherwise, found = false.
    //      If found, location contains the address of someItem and
    //      predLoc contains the address of someItem's predecessor;
    //      otherwise, location contains the address of item's logical
    //      successor and predLoc contains the address of item's
    //      logical predecessor.
{
    bool moreToSearch = true;

    location = listData->next;
    predLoc = listData;
    found = false;

    while (moreToSearch && !found)
    {
        if (item < location->info)
            moreToSearch = false;
        else if (item == location->info)
            found = true;
        else
        {
            predLoc = location;
            location = location->next;
            moreToSearch = (location != listData->next);
        }
    }
}

template<class ItemType>
void SortedType<ItemType>::InsertItem(ItemType item)
{
    NodeType<ItemType>* newNode;
    NodeType<ItemType>* predLoc;
    NodeType<ItemType>* location;
    bool found;

    newNode = new NodeType<ItemType>;
    newNode->info = item;
    if (listData != NULL)
    {
        FindItem(listData, item, location, predLoc, found);
        newNode->next = predLoc->next;
        predLoc->next = newNode;
        // If this is last node in list, reassign listData.
        if (listData->info < item)
            listData = newNode;
    }
    else // Inserting into an empty list.
    {
        listData = newNode;
        newNode->next = newNode;
    }
    length++;
}

template<class ItemType>
void SortedType<ItemType>::DeleteItem(ItemType item)
{
    NodeType<ItemType>* location;
    NodeType<ItemType>* predLoc;
    bool found;

    FindItem(listData, item, location, predLoc, found);
    if (predLoc == location) // Only node in list?
        listData = NULL;
    else
    {
        predLoc->next = location->next;
        if (location == listData) // Deleting last node in list?
            listData = predLoc;
    }
    delete location;
    length--;
}

template<class ItemType>
void SortedType<ItemType>::PrintReverse() {
    NodeType<ItemType>* location = listData;
    int cnt = 0, length = LengthIs();

    cout << location->info << endl;
    while (1) {
        for (int i = 1; i < length; i++) {
            location = location->next;
        }
        cout << location->info << endl;
        cnt++;
        if (cnt == length - 1)
            break;
    }
}

```
이처럼 코드를 구현하게 되면 listData 포인터는 리스트의 맨 끝 노드를 가리키게 되며 그럼에도 무리없이 리스트를 처음부터 탐색할 수 있도록 도와준다. PrintReverse() 함수는 강의 과제로 요구하여 한 번 구현해보았다. 새로 추가된 FindItem() 함수도 분석해보길 바란다.

**2. Doubly Linked List**

Doubly 링크드 리스트는 노드 구조체에 back 포인터를 하나 더 추가해 각 노드가 뒤의 노드만 가리키는 것이 아니라, 앞의 노드도 가리키도록 하는 것이다. 이전의 링크드 리스트에서는 predLoc이라는 포인터 변수를 하나 더 두어 아이템을 제 위치에 삽입할 수 있도록 도움을 주었다. 하지만 이 Doubly 링크드 리스트는 포인터 변수 하나만으로 손쉽게 아이템을 삽입할 수 있도록 도움을 준다.

```c++
// This file contains the code for the FindItem using a doubly
// linked list

template<class ItemType>
struct NodeType
{
  ItemType info;
  NodeType<ItemType>* next;
  NodeType<ItemType>* back;
}
template<class ItemType>
void FindItem(NodeType<ItemType>* listData, ItemType item, 
		    NodeType<ItemType>*& location, bool& found)
// Assumption:  ItemType is a type for which the operators "<" and 
//		"==" are defined--either an appropriate built-in type or a 
//		class that overloads these operations.
// Pre:  List is not empty.
// Post: If there is an element someItem whose key matches item's 
//		key, then found = true; otherwise, found = false. 
//       If found, location contains the address of someItem; 
//       otherwise, location contains the address of the logical 
//		successor of item.
{
  bool moreToSearch = true;

  location = listData;
  found = false;
  while (moreToSearch && !found)
  {
    if (item < location->info)
      moreToSearch = false;
    else if (item == location->info)
      found = true;
    else
    {
        if (location->next == NULL)
            moreToSearch = false;
        else
            location = location->next;
    }
  }
}

template<class ItemType>
void SortedType<ItemType>::InsertItem(ItemType item){
    NodeType<ItemType>* newNode;
    NodeType<ItemType>* location;
    bool found;
    
    newNode = new NodeType<ItemType>;
    newNode->info = item;
    if (listData != NULL){
        FindItem(listData, item, location, found);
        if (location->info > item){
            newNode->back = location->back;
            newNode->next = location;
            if (location != listData)
                (location->back)->next = newNode;
            else // 리스트의 맨 앞에 아이템을 삽입할 때
                listData = newNode;
            location->back = newNode;
        }
        
        else { // 리스트의 맨 뒤에 아이템을 삽입할 때
            newNode->back = location;
            location->next = newNode;
            newNode->next = NULL;
        }
    }
    else { // 리스트에 첫 아이템을 삽입할 때
        listData = newNode;
        newNode->next = NULL;
        newNode->back = NULL;
    }
    length++;
}

```
Doubly 링크드 리스트를 기반으로 한 노드 구조체와 FindItem() 함수 및 InsertItem() 함수를 구현해보았다. 많은 주석에서 알 수 있다시피 특이 케이스가 많기 때문에 조건문을 많이 사용하여 코드가 매우 복잡해보인다. 이를 해결할 수 있는 방법은 dummy 노드를 만드는 것이다.(Header와 Trailer) 코드가 간단해지지만 쓸모없는 두 메모리를 쓰게 된다는 단점이 있다. 이를 토대로 TextEditor를 과제로 한 번 구현해보았다.

**TextEditor.h**
```c++
#include <iostream>
using namespace std;

struct LineType
{
	char info[80];
	LineType* next;
	LineType* back;
};

class TextEditor
{
	LineType* currentLine;

public:
	TextEditor();
	~TextEditor();
	void GoToTop();
	void GoToBottom();
	void InsertItem(char newline[]);
	void Print();
};

TextEditor::TextEditor() {
	LineType* header = new LineType;
	LineType* tailer = new LineType;

	strcpy_s(header->info, sizeof("---Top of file---"), "---Top of file---");
	strcpy_s(tailer->info, sizeof("---Bottom of file---"), "---Bottom of file---");

	header->next = tailer;
	tailer->back = header;
	header->back = NULL;
	tailer->next = NULL;

	currentLine = header;
}

TextEditor::~TextEditor() {
	LineType* tempPtr;

	GoToTop();

	currentLine = currentLine->back;

	while (currentLine->next != NULL)
	{
		tempPtr = currentLine;
		currentLine = currentLine->next;
		delete tempPtr;
	}
	delete currentLine;
}

void TextEditor::GoToTop() {

	while (currentLine->back != NULL)
		currentLine = currentLine->back;

	currentLine = currentLine->next;
}

void TextEditor::GoToBottom() {

	while (currentLine->next != NULL)
		currentLine = currentLine->next;

	currentLine = currentLine->back;
}

void TextEditor::InsertItem(char newline[])
{
	LineType* location;

	GoToBottom();

	location = new LineType;

	for (int i = 0; i <= strlen(newline); i++) {
		location->info[i] = newline[i];
	}
	/*for (int i = 0; newline[i] != '\0'; i++) {
		location->info[i] = newline[i];
	}*/
	location->back = currentLine;
	location->next = currentLine->next;

	currentLine->next->back = location;
	currentLine->next = location;
}

void TextEditor::Print() {
	GoToTop();

	while (currentLine->next != NULL) {
		cout << currentLine->info << endl;
		currentLine = currentLine->next;
	}
}

```
이런 식으로 클래스의 기본 생성자에 header와 trailer를 생성해주면 InsertItem() 함수를 사용할 때 훨씬 간단해 지는 것을 확인할 수 있다. Doubly 링크드 리스트의 DeleteItem() 함수는 직접 구현해보는 것을 추천한다.

**3. Linked List as An Array**

배열 기반으로 만들어진 링크드 리스트를 구현할 수 있다. 포인터 없이 각 노드의 공간을 배열로 구현하고 그 노드 안에는 info와 next를 멤버 변수로 두어 마치 연결하는 듯한 느낌을 주는 것이다. 이 클래스의 경우에도 2개의 멤버 변수가 필요하다. 변수 list는 이 리스트의 시작이 어디인지 index값을 저장하고, free는 빈 공간이 어디인지 저장한다. 다음은 책에서 제공하는 코드이다.

**ArrayLL.h**

```c++
// file: ArrayLL.cpp

// This file contains the code for the array-of-records implementation
// in the text.  Incomplete definitions of ListType and NodeType and
// one stub routine have been included to confirm that the syntax of
// this code is correct. The student must write a complete definition
// to use this code.

// Compile: 
// bcc32 ArrayLL.cpp

typedef int ItemType;

struct NodeType;

struct MemoryType
{
  int free;
  NodeType* nodes;
};

// An incomplete definition of ListType sufficient to compile the code
// in the array linked list implementation

class ListType
{
public:
  ListType();
  ListType(int);
  ~ListType();
  
  // Other member function prototypes go here.
  void MakeEmpty();
  bool IsFull() const;
  int  LengthIs() const;
  void RetrieveItem(ItemType& item, bool& found);
  void InsertItem(ItemType item);
  void DeleteItem(ItemType item);
  void ResetList();
  void GetNextItem(ItemType& item);

 
private:
  int listData;
  int currentPos;
  int length;
  int maxItems;
  MemoryType storage;
};
```

**ArrayLL.cpp**

```c++
#include "ArrayLL.h"
// Prototypes of auxiliary functions.

void GetNode(int& nodeIndex, MemoryType& storage);
// Returns the index of a free node in nodeIndex.
void FreeNode(int nodeIndex, MemoryType& storage);
// Returns nodeIndex to storage.
void InitializeMemory(int maxItems, MemoryType&);
// Initializes all memory to the free list.

// Define end-of-list symbol.
const int NUL = -1;

struct NodeType
{
  int info;
  int next;
};


// Definitions of the auxillary functions

void InitializeMemory(int maxItems, MemoryType& storage)
{
  for (int index = 1; index < maxItems; index++)
    storage.nodes[index-1].next = index;
  // storage.nodes[maxItems-1] = NUL; 
  storage.nodes[maxItems-1].next = NUL; 
  storage.free = 0;
}

void GetNode(int& nodeIndex, MemoryType& storage)
{
  nodeIndex = storage.free;
  //error:    storage.free = storage.nodes[free].next;
  storage.free = storage.nodes[storage.free].next;
}

void FreeNode(int nodeIndex, MemoryType& storage)
{
  storage.nodes[nodeIndex].next = storage.free;
  storage.free = nodeIndex;
}

//The class constructors for class ListType must allocate the storage
//for the array of records and call InitializeMemory.  For the default
//constructor, we arbitrarily choose an array size of 500.

ListType::ListType(int max)
{
  length = 0;
  maxItems = max;
  storage.nodes = new NodeType[max];
  InitializeMemory(maxItems, storage);
  listData = NUL;
}

ListType::ListType()
{
  length = 0;
  maxItems = 500;
  storage.nodes = new NodeType[500];
  InitializeMemory(500, storage);
  listData = NUL;
}

ListType::~ListType()
{
  delete [] storage.nodes;
}

void InsertItem(ItemType item)
{
  // STUB: REPLACE WITH USEFUL CODE.
}

```
뒤에서 다룰 것이 많아 책에서 제공하는 코드로 대체하고 넘어가도록 한다.

**4. Stack Copy Constructor**

이 파트에서는 기존의 스택을 그대로 깊은 복사하여 새로운 스택을 만드는 방법에 대해 고민해볼 것이다. 스택을 복사하면서 topPtr 포인터만 공유하게 되는 얕은 복사를 하게 되면 한 쪽 스택에서 topPtr 포인터가 가리키는 노드를 Pop() 시킨 경우에 다른 한 쪽 스택에서는 아무것도 없는 주소에 접근하게 되므로 오류가 발생하게 된다. 따라서, 스택을 복사하기 위해서는 반드시 깊은 복사를 하여 모두 새로운 주소에 할당해줘야 한다. 다음과 같은 방법을 사용하여 스택을 복사해볼 예정이다.
- 복사 생성자
- 멤버 함수
- 클라이언트 함수
- 연산자 오버로딩

**Copy Constructor**
```c++
StackType::StackType(const StackType& anotherStack)
{
    NodeType* ptr1;
    NodeType* ptr2;
    if (anotherStack.topPtr == NULL)
        topPtr = NULL;
    else {
        topPtr = new NodeType;
        topPtr->info = anotherStack.topPtr->info;
        ptr1 = anotherStack.topPtr->next;
        ptr2 = topPtr;
        while (ptr1 != NULL){
            ptr2->next = new NodeType;
            ptr2 = ptr2->next;
            ptr2->info = ptr1->info;
            ptr1 = ptr1->next;
        }
        ptr2->next = NULL;
    }
}
```

**Member Function**

```c++
void StackType::Copy(StackType& anotherStack) {
    topPtr = NULL;
    NodeType* location = anotherStack.topPtr;

    while (location != NULL)
    {
        NodeType* temp = new NodeType;
        if (topPtr == NULL)
        {
            temp->info = location->info;
            temp->next = topPtr;
            topPtr = temp;
            location = location->next;
        }
        else
        {
            temp->info = location->info;
            temp->next = NULL;

            NodeType* location2 = topPtr;
            while (location2->next != NULL)
            {
                location2 = location2->next;
            }
            location2->next = temp;
            location = location->next;
        }
    }
}
```

**Client Function**

```c++
void Copied(StackType& stack, StackType& anotherStack){
    StackType temp;
    ItemType a;
    while (!stack.IsEmpty()){
        a = stack.Top();
        stack.Pop();
        temp.Push(a);
    }
    while (!temp.IsEmpty()){
        a = temp.Top();
        temp.Pop();
        stack.Push(a);
        anotherStack.Push(a);
    }
}
```

**Operator Overloading**

```c++
void StackType::operator=(StackType& anotherStack){
    NodeType* ptr1;
    NodeType* ptr2;
    if (anotherStack.topPtr == NULL)
        topPtr = NULL;
    else {
        topPtr = new NodeType;
        topPtr->info = anotherStack.topPtr->info;
        ptr1 = anotherStack.topPtr->next;
        ptr2 = topPtr;
        while (ptr1 != NULL){
            ptr2->next = new NodeType;
            ptr2 = ptr2->next;
            ptr2->info = ptr1->info;
            ptr1 = ptr1->next;
        }
        ptr2->next = NULL;
    }
}
```
클래스 내 연산자 오버로딩이 아닌 Friend를 사용해서도 구현할 수 있어야한다. 이 부분은 C++ 기본 지식이기 때문에 구현하지 않고 마친다.


**Python을 이용한 구현**

1. Circular Linked List

```python
class NodeType:
    """ Node Type """
    def __init__(self, item):
        self.info = item
        self.next = None

class CircularLL:
    def __init__(self):
        self.listData = None
        self.length = 0
        self.currentPos = None

    def is_full(self):
        try:
            location = NodeType("test")
            return False
        except:
            return True

    def length_is(self):
        return self.length

    def make_empty(self):
        while self.listData != None:
            tempPtr = self.listData.next
            del self.listData
            self.listData = tempPtr
        self.length = 0

    def find_item(self, listData, item):
        '''[4]'''
        more_to_search = True
        location = listData.next
        predLoc = listData
        found = False

        while more_to_search and not found:
            if item < location.info:
                more_to_search = False
            elif item == location.info:
                found = True
            else:
                predLoc = location
                location = location.next
                more_to_search = (location != listData.next)
        return predLoc
    
    def insert_item(self, item):
        '''[5]'''
        newNode = NodeType(item)
        if self.listData != None:
            predLoc = self.find_item(self.listData, item)
            newNode.next = predLoc.next
            predLoc.next = newNode
            if self.listData.info < item:
                self.listData = newNode
        else:
            self.listData = newNode
            newNode.next = newNode
        self.length += 1


    def delete_item(self, item):
        '''[6]'''
        predLoc = self.find_item(self.listData, item)
        location = predLoc.next
        if predLoc == location:
            self.listData = None
        else:
            predLoc.next = location.next
            if location == self.listData:
                self.listData = predLoc
        
        del location
        self.length -= 1
   

    def reset_list(self):
        self.currentPos = None

    def get_next_item(self):
        if self.currentPos == None:
            self.currentPos = self.listData
        else:
            self.currentPos = self.currentPos.next
        return self.currentPos.info

    def __str__(self):
        self.reset_list()
        items = []
        for i in range(0, self.length):
            t = self.get_next_item()
            items.append(str(t))
        return "\n".join(items)

```
2. Doubly Linked List


```python
class NodeType:
    """ Node Type """
    def __init__(self, item):
        self.info = item
        self.next = None
        self.back = None

class DoublyLL:
    def __init__(self):
        self.head = NodeType('head')
    
    def find_item(self, item):
        '''[1]'''
        location = self.head
        more_to_search = True
        found = False
        while more_to_search and not found:
            if item == location.info:
                found = True
            else:
                if location.next == None:
                    more_to_search = False
                else:
                    location = location.next
        return location
    
    def insert_item(self, item, new):
        '''[2]'''
        newNode = NodeType(new)
        location = self.find_item(item)
        if location.next == None:
            newNode.next = None
        else:
            newNode.next = location.next
            location.next.back = newNode
        newNode.back = location
        location.next = newNode

    def delete_item(self, item):
        '''[3]'''
        location = self.find_item(item)
        if location.next == None:
            location.back.next = None
        else:
            location.back.next = location.next
            location.next.back = location.back
            
    def __str__(self):
        cur_node = self.head
        items = []
        while cur_node is not None:
            items.append("(" + str(cur_node.info) + ")\n")
            cur_node = cur_node.next
        return "".join(items)


```

3. Stack Copy Constructor

```python
class NodeType:
    """ Node Type """
    def __init__(self, item):
        self.info = item
        self.next = None

class StackType:
    def __init__(self):
        self.topPtr = None

    def is_full(self):
        try:
            location = NodeType("test")
            del location
            return False
        except:
            return True

    def is_empty(self):
        return self.topPtr == None

    def push(self, item):
        if self.is_full():
            print("Failed to Push")
        else:
            location = NodeType(item)
            location.next = self.topPtr
            self.topPtr = location

    def pop(self):
        if self.is_empty():
            print("Failed to Pop")
        else:
            tempPtr = self.topPtr.info
            self.topPtr = self.topPtr.next
            return tempPtr

    def top(self):
        if self.is_empty():
            print("Failed to Top")
        else:
            return self.topPtr.info

    def __str__ (self):

        location = self.topPtr
        items = []
        while location != None:
            items.append(location.info)
            location = location.next

        return " ".join(items)

    def copy(self, anotherStack):
        '''[7]'''            
        if anotherStack.topPtr == None:
            self.topPtr = None
        else:
            self.topPtr = NodeType(anotherStack.topPtr.info)
            ptr1 = anotherStack.topPtr.next
            ptr2 = self.topPtr
            while ptr1 != None:
                ptr2.next = NodeType(1)
                ptr2 = ptr2.next
                ptr2.info = ptr1.info
                ptr1 = ptr1.next
            ptr2.next = None
```


![png](/assets/img/9/1.png){: width="100%"}