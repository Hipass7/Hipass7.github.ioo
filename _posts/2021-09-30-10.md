---
layout: post
title:  "[3-3] ADTs Sorted List / 정렬 리스트"
summary: 
author: hipass7
date: '2021-09-30 19:00:00 +0900'
category: C++
thumbnail: /assets/img/9/1.png
permalink: /blog/10/
---

# [3-3] ADTs Sorted List

- 추상 자료형 정렬 리스트 구현
- `경희대학교 C++ / Python 자료구조 강의 정리`

// 이전에 비정렬 리스트 포스트에서 사용한 글을 그대로 인용하였다.

### 도입

주위에서 많은 자료들을 관리하기 위해서는 리스트가 필요하다. 출입 명부, 명단 등 우리는 실생활에서 리스트를 사용하고 있다. 컴퓨터 프로그램에서 이 리스트는 매우 중요한 추상 자료형이다. 그것은 서로 다른 객체들을 담는 것이 목적인 추상 자료형의 멤버이다. 이 리스트는 항목간의 선형 관계를 가지고 있고 정렬 리스트의 경우 이 안에 있는 자료 항목들이 특별한 순서를 통해 위치해 있는 것을 말한다.

**Generic Data Types**

일반 자료형은 그것에 대한 연산은 정의되지만 다루어져야 할 항목들의 형들은 정의되지 않은 것이다. 따라서 리스트 내에 있는 항목들을 직접적으로 비교할 수가 없기 때문에 클래스 ItemType을 사용하여 추상자료형(ADT)로 만들어 줄 것이다.

**class ItemType**

추상자료형을 사용하기 위해 ItemType class를 만들어줄 것이다. 기본적으로 생성자와 다른 ItemType과 비교하는 함수, 객체를 print하는 함수, 그리고 초기화하는 함수로 총 5개의 method를 구현할 것이다. 아래와 같다.

```c++
enum RelationType {LESS, GREATER, EQUAL};
class ItemType {
	int value;
public:
	ItemType();
    ItemType(int);
	RelationType ComparedTo(ItemType) const;
	void Print(std::ostream&) const;
	void Initialize(int number);
};
```
이렇게 헤더파일에 넣을 class는 구현이 완성되었고 이제 소스파일에 들어갈 함수들을 직접 구현해본다.

```c++
#include "ItemType.h"

ItemType::ItemType()
{ 
  value = 0;
}

ItemType::ItemType(int num)
{
    value = num;
}

RelationType ItemType::ComparedTo(ItemType otherItem) const 
{
  if (value < otherItem.value)
    return LESS;
  else if (value > otherItem.value)
    return GREATER;
  else return EQUAL;
}

void ItemType::Initialize(int number) 
{
  value = number;
}

void ItemType::Print(std::ostream& out) const 
{
  out << value;
}
```

가장 눈에 띄는 함수는 ComparedTo이다. parameter로 받은 ItemType과 대소관계를 따져서 RelatinType으로 지정된 Enum의 값으로 반환한다. 이를 토대로 리스트에 있는 값을 찾거나 삭제하는데 사용할 수 있다. 비정렬 리스트와 똑같이 정렬 리스트 또한 이 class가 필요하다.

**class UnsortedType**

어떤 추상 자료형 리스트를 설계하기 위해서는 다음의 4종류의 연산들이 있다는 것을 알아야한다. ※ 생성자, 변환자, 관찰자, 반복자

1. Constructor
- 추상 자료형 리스트를 새로 만드는 선언이다.
```c++
SortedType();
```

2. Transformer
- 리스트 안에 있는 데이터의 객체값을 변화시키는 함수이다.
```c++
void MakeEmpty();
void InsertItem(ItemType item);
void DeleteItem(ItemType item);
```


3. Observer
- 리스트 안에 있는 데이터를 변화시키지 않고 값을 가져오는 함수이다.
- 데이터를 변화시키지 않으므로 const형 함수로 선언해준다.
```c++
bool IsFull() const;
int LengthIs() const;
void RetrieveItem(ItemType& item, bool& found);
```

4. Iterator
- 리스트 안에 있는 데이터에 접근할 수 있게 해주는 함수이다.
```c++
void ResetList();
void GetNextItem(ItemType& item);
```

아래와 같이 헤더파일에 class의 정의를 작성해준다.

```c++
class SortedType 
{
	int length;
	ItemType info[MAX_ITEMS]; // 배열로 선언
	int currentPos;
public:
  SortedType();
  // Constructor
  bool IsFull() const;
  // Function:  Determines whether list is full.
  // Pre:  List has been initialized.
  // Post: Function value = (list is full)

  int LengthIs() const;
  // Function: Determines the number of elements in list.
  // Pre:  List has been initialized.
  // Post: Function value = number of elements in list

  void RetrieveItem(ItemType& item, bool& found);
  // Function: Retrieves list element whose key matches item's key (if
  //           present).
  // Pre:  List has been initialized.
  //       Key member of item is initialized.
  // Post: If there is an element someItem whose key matches
  //       item's key, then found = true and item is a copy of
  //       someItem; otherwise found = false and item is unchanged.
  //       List is unchanged.

  void InsertItem(ItemType item);
  // Function: Adds item to list.
  // Pre:  List has been initialized.
  //       List is not full.
  //       item is not in list.
  // Post: item is in list.

  void DeleteItem(ItemType item);
  // Function: Deletes the element whose key matches item's key.
  // Pre:  List has been initialized.
  //       Key member of item is initialized.
  //       One and only one element in list has a key matching item's key.
  // Post: No element in list has a key matching item's key.

  void ResetList();
  // Function: Initializes current position for an iteration through the list.
  // Pre:  List has been initialized.
  // Post: Current position is prior to list.

  void GetNextItem(ItemType& item);
  // Function: Gets the next element in list.
  // Pre:  List has been initialized and has not been changed since last call.
  //       Current position is defined.
  //       Element at current position is not last in list.
  //	     
  // Post: Current position is updated to next position.
  //       item is a copy of element at current position.
```

여기서부터 비정렬 리스트와 다른 점을 발견할 수 있다. 비정렬 리스트와 다르게 정렬 리스트는 새로운 item을 추가할 때, 원래 있던 일정한 규칙에 맞춰 추가를 해야하며 삭제를 할 때도 마찬가지로 삭제한 이후에도 일정한 규칙에 맞도록 다시 재구성해주어야 한다. 그리고 분명 리스트 안의 해당 item을 찾는데에도 일정한 규칙이 있기 때문에 더욱 간편한 방법을 사용할 수 있을 것이다. 나머지 함수는 비정렬 리스트에서 구현된 것과 비슷하므로 여기에서는 InsertItem, DeleteItem, RetrieveItem 함수만 살펴보도록 한다.

1. InsertItem
```c++
void SortedType::InsertItem(ItemType item) 
{
  bool moreToSearch;
  int location = 0;

  moreToSearch = (location < length);
  while (moreToSearch) 
  {
    switch (item.ComparedTo(info[location])) 
    {
      case LESS    : moreToSearch = false;
                     break;
      case GREATER : location++;
                     moreToSearch = (location < length);
                     break;
    } 
  } 
  for (int index = length; index > location; index--)
    info[index] = info[index - 1];
  info[location] = item;
  length++;
}
```
우선 moreToSearch라는 boolean형 변수를 선언해준다. (굳이 사용하지 않고 구현하는 방법도 있긴 하다.) location 변수를 iterator를 사용하여 리스트의 길이만큼 1씩 증가시키면서 탐색을 한다. 이 때 인수로 받은 item의 값이 리스트 내의 값보다 큰 경우 순차적으로 탐색을 계속 진행하며 리스트 내의 값보다 작을 경우, 그 위치에 item을 추가하기 위해 공간을 만든다. 공간을 만드는 방법은 현재 location의 위치에 있는 item을 기준으로 배열 안에서 뒤로 한 칸씩 밀어주고 location의 위치에 item을 할당하는 것이다. 이후 리스트의 length 값을 1 증가시켜준다. 그렇게되면 규칙을 깨지 않는 선에서 새로운 item을 추가하는 과정이 쉽게 이루어진 것이다.

2. DeleteItem



하지만 책에 구현되어있는 DeleteItem(ItemType item) 함수에는 문제가 있었다. 비정렬 리스트 내에 인수1로 입력한 item의 값이 존재하지 않는 경우와, 2개 이상 들어있는 경우에 어떻게 처리할 것인지 밝혀지지 않았다. 따라서 그러한 경우를 생각한 함수를 직접 구현해보았다.
```c++
// item의 값이 존재하지 않는 경우를 생각하여 보완한 함수
void UnsortedType::DeleteItem_a(ItemType item)
{
    bool deleted = false;
    int i = 0;
    for (i = 0; i < length && !deleted; i++)
    {
        if (item.ComparedTo(info[i]) == EQUAL)
        {
            info[i] = info[length - 1];
            length--;
            deleted = true;
        }
    }
}

// item의 값이 2개 이상 존재하는 경우를 생각하여 보완한 함수
void UnsortedType::DeleteItem_c(ItemType item)
{
    int i = 0;

    while (i < length)
    {
        if (item.ComparedTo(info[i]) == EQUAL)
        {
            info[i] = info[length - 1];
            length--;
        }
        else
        {
            i++;
        }
    }
}
```

이런식으로 책에 구현되어 있는 비정렬 리스트 class의 기능들을 모두 익히고 문제점을 찾아보기도 하며 문제를 해결해나갈 수 있는 능력을 키울 수 있었다. 비정렬 리스트의 경우, 상식과 다른 부분이 하나 있었는데 바로 DeleteItem 함수를 이용할 때, 굳이 리스트의 맨 뒤에 있는 요소를 빈 자리에 가져온 뒤 맨 뒤에 있는 요소에는 접근하지 않도록 length 변수값만 하나 줄이는 것이었다. 비정렬이기 때문에 가능한 일이라 바로 이해할 수 있었다. 이 class를 이용하여 직접 함수 구현을 해보며 결과를 확인하면 더욱 이해가 편리할 것이다. 직접 해보는 것이 최고다.

![png](/assets/img/9/1.png){: width="100%"}