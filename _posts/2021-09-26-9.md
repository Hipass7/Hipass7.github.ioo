---
layout: post
title:  "[3-2] ADTs Unsorted List"
summary: 
author: hipass7
date: '2021-09-26 19:00:00 +0900'
category: C++
thumbnail: /assets/img/9/1.png
permalink: /blog/9/
---

# [3-2] ADTs Unsorted List

- 추상 자료형 비정렬 리스트 구현
- `경희대학교 C++ / Python 자료구조 강의 정리`

### 도입

주위에서 많은 자료들을 관리하기 위해서는 리스트가 필요하다. 출입 명부, 명단 등 우리는 실생활에서 리스트를 사용하고 있다. 컴퓨터 프로그램에서 이 리스트는 매우 중요한 추상 자료형이다. 그것은 서로 다른 객체들을 담는 것이 목적인 추상 자료형의 멤버이다. 이 리스트는 항목간의 선형 관계를 가지고 있고 비정렬 리스트의 경우 이 안에 있는 자료 항목들이 특별한 순서 없이 위치해 있는 것을 말한다.

**Generic Data Types**

일반 자료형은 그것에 대한 연산은 정의되지만 다루어져야 할 항목들의 형들은 정의되지 않은 것이다. 따라서 리스트 내에 있는 항목들을 직접적으로 비교할 수가 없기 때문에 클래스 ItemType을 사용하여 추상자료형(ADT)로 만들어 줄 것이다.

**class ItemType**

추상자료형을 사용하기 위해 ItemType class를 만들어줄 것이다. 기본적으로 생성자와 다른 ItemType과 비교하는 함수, 객체를 print하는 함수, 그리고 초기화하는 함수로 총 5개의 method를 구현할 것이다. 아래와 같다.

```c++
enum RelationType {LESS, GREATER, EQUAL};
class ItemType {
	int value;
public:
	ItemType();
    ItemType(int);
	RelationType ComparedTo(ItemType) const;
	void Print(std::ostream&) const;
	void Initialize(int number);
};
```
이렇게 헤더파일에 넣을 class는 구현이 완성되었고 이제 소스파일에 들어갈 함수들을 직접 구현해본다.

```c++
#include "ItemType.h"

ItemType::ItemType()
{ 
  value = 0;
}

ItemType::ItemType(int num)
{
    value = num;
}

RelationType ItemType::ComparedTo(ItemType otherItem) const 
{
  if (value < otherItem.value)
    return LESS;
  else if (value > otherItem.value)
    return GREATER;
  else return EQUAL;
}

void ItemType::Initialize(int number) 
{
  value = number;
}

void ItemType::Print(std::ostream& out) const 
{
  out << value;
}
```

가장 눈에 띄는 함수는 ComparedTo이다. parameter로 받은 ItemType과 대소관계를 따져서 RelatinType으로 지정된 Enum의 값으로 반환한다. 이를 토대로 리스트에 있는 값을 찾거나 삭제하는데 사용할 수 있다.

**class UnsortedType**

어떤 추상 자료형 리스트를 설계하기 위해서는 다음의 4종류의 연산들이 있다는 것을 알아야한다. ※ 생성자, 변환자, 관찰자, 반복자

```c++
class UnsortedType 
{
	int length;
	ItemType info[MAX_ITEMS]; // 배열로 선언
	int currentPos;
public:
  UnsortedType();
  // Constructor
  bool IsFull() const;
  // Function:  Determines whether list is full.
  // Pre:  List has been initialized.
  // Post: Function value = (list is full)

  int LengthIs() const;
  // Function: Determines the number of elements in list.
  // Pre:  List has been initialized.
  // Post: Function value = number of elements in list

  void RetrieveItem(ItemType& item, bool& found);
  // Function: Retrieves list element whose key matches item's key (if
  //           present).
  // Pre:  List has been initialized.
  //       Key member of item is initialized.
  // Post: If there is an element someItem whose key matches
  //       item's key, then found = true and item is a copy of
  //       someItem; otherwise found = false and item is unchanged.
  //       List is unchanged.

  void InsertItem(ItemType item);
  // Function: Adds item to list.
  // Pre:  List has been initialized.
  //       List is not full.
  //       item is not in list.
  // Post: item is in list.

  void DeleteItem(ItemType item);
  // Function: Deletes the element whose key matches item's key.
  // Pre:  List has been initialized.
  //       Key member of item is initialized.
  //       One and only one element in list has a key matching item's key.
  // Post: No element in list has a key matching item's key.

  void ResetList();
  // Function: Initializes current position for an iteration through the list.
  // Pre:  List has been initialized.
  // Post: Current position is prior to list.

  void GetNextItem(ItemType& item);
  // Function: Gets the next element in list.
  // Pre:  List has been initialized and has not been changed since last call.
  //       Current position is defined.
  //       Element at current position is not last in list.
  //	     
  // Post: Current position is updated to next position.
  //       item is a copy of element at current position.
  void DeleteItem_a(ItemType item);
  // function : key로 지정한 item의 값이 리스트 안에 있는 item의 값과 같은 경우 삭제한다.
  // precondition : key값과 리스트가 초기화 되어있다. 리스트에 삭제할 item이 없거나 하나만 존재한다.
  // postcondition : 리스트에 삭제할 item이 없으면 리스트를 변경하지 않는다. key로 지정한 item이 리스트 안에 없을 수도 있다.
  void DeleteItem_c(ItemType item);
  // function : key로 지정한 item과 리스트에 같은 item이 있으면 삭제한다.
  // precondition : key값과 리스트가 초기화 되어있다. 리스트에 삭제할 key값과 동일한 item이 여러 개 존재할 수도 있다.
  // postcondition : 리스트 내에 key값과 일치하는 item이 있으면 모두 삭제한다.
};
```

```c++
#include "unsorted.h"

UnsortedType::UnsortedType()
{
  length = 0;
}
bool UnsortedType::IsFull() const
{
  return (length == MAX_ITEMS);
}

int UnsortedType::LengthIs() const
{
  return length;
}
void UnsortedType::RetrieveItem(ItemType& item, bool& found) 

{
  bool moreToSearch;
  int location = 0;
  found = false;

  moreToSearch = (location < length);

  while (moreToSearch && !found) 
  {
    switch (item.ComparedTo(info[location]))
    {
      case LESS    : 
      case GREATER : location++;
                     moreToSearch = (location < length);
                     break;
      case EQUAL   : found = true;
                     item = info[location];
                     break;
    }
  }
}
void UnsortedType::InsertItem(ItemType item)

{
  info[length] = item;
  length++;
}
void UnsortedType::DeleteItem(ItemType item)

{
  int location = 0;

  while (item.ComparedTo(info[location]) != EQUAL)
    location++;

  info[location] = info[length - 1];
  length--;
}
void UnsortedType::ResetList()

{
  currentPos = -1;
}

void UnsortedType::GetNextItem(ItemType& item)

{
  currentPos++;
  item = info[currentPos];
}

void UnsortedType::DeleteItem_a(ItemType item)
{
    bool deleted = false;
    int i = 0;
    for (i = 0; i < length && !deleted; i++)
    {
        if (item.ComparedTo(info[i]) == EQUAL)
        {
            info[i] = info[length - 1];
            length--;
            deleted = true;
        }
    }
}

void UnsortedType::DeleteItem_c(ItemType item)
{
    int i = 0;

    while (i < length)
    {
        if (item.ComparedTo(info[i]) == EQUAL)
        {
            info[i] = info[length - 1];
            length--;
        }
        else
        {
            i++;
        }
    }
}
```

** 수정중 **

![png](/assets/img/9/1.png){: width="100%"}